Hoy 14/11 vamos a empezar con el backend. Lo primero es crear la carpeta VAULTCRYPT-BACKEND y abrirla en el bash o windows power shell y ejecutar el comando npm init -y
Instalamos las dependencias de desarrollo y los typados: express, jsonwebtoken, bcrypt y dotenv
ejecutamos npx tsc --init para que se configure typescript y luego en tsconfig.json comentamos el compilerOptions que obtuvimos automaricamente por el siguiente:
"compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true
  }
Creamos la carpeta SRC y dentro las carpetas API y UTILS
A la par de SRC creamos los archivos .env y vercel.json
El archivos vercel.json es para configurar l servicio de Vercel que es la plataforma donde vamos a desplegar el backend y lo que escribimos dentro es:
{
  "functions": {
    "api/**/*.ts": {
      "runtime": "nodejs20.x"
    }
  }
}
Establecimos la primera variable de entonrno JWT_SECRET
Empezamos a trabajar con el primer endpoint. Creamos el archivo usuario.ts dentro de la carpeta API y declaramos la funcion asincrona handlerPost que recibira el cuerpo de la solicitud y lo desestructurara  en email y password para procesarlo y devolver el objeto usuario, el token y el mensaje de exito. Esto es para hacer el registro de un usuario, pero falta adaptarlo para uqe reviba la palabra secreta y el nombre del usuario
Vamos a crear dentro de SRC la carpeta TYPES y dentro del archivo vercel.ts. Aqui vamos a declarar y exportar las interfaces VercelRequest y VercerResponse
Procederemos a haer una testeo local con Postman haciendo una solicitud POST al endpoint http://localhost:3000/api/usuario con el cuerpo {"email": "oscar@vaultcrypt.com","password": "claveSegura123"}
Salto el primer error. Primero que nada nos falto desarrollar en index.ts la configuracion de las variables de entorno y la aplicacion de express. Una vez hecho eso y ejecutando npx ts-node src/index.ts en la consola del VScode el servidor se levanto y pudimos realizar la solicitud POST de postman satisfactoriamente
Lo que sigue es la primer subida a github para eso ejecutamos git init en la consola del VScode y creamos el archivo .gitignore que debe enlistar a node_module, .env y a dist/

## Dia 2 (17/11)
Hoy vamos a trabajar en el endpoint del login, ya tenemos el endpoint de resgistro en usuario.ts. Empezaremos creadon el archivo login.ts dentro de la carpeta API.
Declaramos la funcion handlerPostLogin para verificar el logueo de un usuario y lo dejamos operativo y probado por Postman
Al empezar a trabajar con el endpoint GET de usuarios la IA sugirio extender la funcion del archicos usuario.ts, por lo que le hare las siguientes modificaciones: cambiare el nombre a usersHandler y metera la logica del registro de usuario dentro de un IF que verifique el metodo de la solicitud y use ELSE IF para las otras dos (GET y PUT) de esta manera unificara las funciones POST, GET y PUT en el archivo usuario.ts
Hemos dejado creados las 3 funciones recien mencionada dejando mensajes del lugar donde va la logica de base de datos

## Dia 3 (18/11)
Hoy vamos a trabajar los endpoints de relacionados a la gestion de cuentas, principalmente desarrollaremos el GET y el POST
Primero vamos a ir a la carpeta TYPES para crear el tipado de cuentas
Le pedi a copilot para hacer el desarrollo del endpoint, pero no me convencio la respuesta. Asique tome la use el POST de usuario.ts y lo adapte para funcionar con cuentas. Me tope con el problmea de que necesito obtener el id del usuario desde el frontend para ponerlo como userId de la nueva cuenta
Lo que se me ocurrio es que el id del usuario este cifrado dentro del token junto con el email del usuario. Esto plantea que debo modificar la funcion de login y register
Para evitar complicaciones decidi que al hacer login o register el backend devuelva el token y el objeto usuario. Con esto solo pude dejar completo el POST de nuevaCuenta. falta probarlo

## Dia 4 (19/11)
Empezaremos el dia probando el endpoint de cuentas. La prueba con Postman ha funcionado perfectamente
Seguiremoos con el GET de las cuentas. Como hicimos con POST tomaremos el codigo de GET de usuario.ts y lo adaptaremos
He dicidio crear un middleware para verificar el token y usarlo en las solicitudes de post y GET  de la gestion de cuentas. Tambien lo usare cuando haya que modificar los datos del usaurio. Creare el archivo tokenverificator.ts dentro de la carpeta UTILS 
He dajado operativos y probados el POST y GET de gestion de cuentas a traves de la verificacion por token

##Falta hacer: editar el PUT de usuario.ts para que verifique por token
Dia 5 (20/11)
Para hoy quiero dejarr todo listo para trabajar en la implementacion de la logica de base de datos. Para esto debo dejar los objeto usuario y cuenta acordes al front-end.
Empezaremos con el objeto Usuario le agregue name, emailPrincipal, emailList, role y secretWord
El objeto accounts desde un principio lo construi del modo en lo que lo quiero
Ya actualice el PUT para usar la funcion del archivo tokenverificator.ts y antes de terminar el dia actualizare el objeto Account o Cuenta del front-end

## Dia 6(21/11) Crearemos y aplicaremos la logica de base de datos
Las opsiones son PostgreSQL y MongoDB. Segun entiendo PostgreSQL es mas estricto con el tipado asique lo usaremos ya que va a la par con typescript y el OMR sera Prisma
Primero definiremos los modelos de Usuario y Cuenta. Voy a crear la carpeta MODELS y dentro el archivo prismaModels.ts (probaablemente no lo use en el flujo del proyecto) que es donde voy a declarar los modelos. Ya que ambos tienen un campo de opsiones (Usuario tiene role y Cuenta tiene serviceType) a cada uno le haremos un enum para que prisma les asigne unicamente esos valores. Lo que sigue es ejecutar en la terminal un npm install prisma @prisma/client para instalar las dependencias de Prisma y luego lo ejecutare con npx prisma init
Una vez iniciado prisma la url de base de datos que se creo en el archivo .env y lo dejaremos asi: DATABASE_URL="postgresql://mauricio:gonzalez@localhost:5432/vaultcrypt"
Podemos ver que se creo la carpeta PRISMA y dentro el archivo shema.prisma y luego para quedarnos tranquilos ejecutamos el comando npx prisma validate que es propio de prisma y verifica que las relaciones y asignaciones esten correctas
Lo que sigue es ejecutar npx prisma migrate dev --name init, esto crea las tablas en la base de datos segun el modelo y salto un problema: Can't reach database server at `localhost:5432`. Esto es porque la base de datos no esta levantada ni corriendo asique haremos lo siguiente: 
ir a https://www.postgresql.org/download/ y descargar PostgreSQL para Windows. Instalamos PostgreSQL en la compu y declaramos como contrase침a "gonzalez" y el puerto "5432"
Una vez completada la instalacion modificamos la url del archivo .env y la dejamos como DATABASE_URL="postgresql://postgres:gonzalez@localhost:5432/vaultcrypt". Volvimos a ejecutar npx validate y como salio bien ahora pasamos a la migracion con npx prisma migrate dev --name init. Fue un exito asique ya estamos listos para generar el cliente de prisma
El cliente de prisma es como la libreria que nos dara los metodos findMany, findUnique , etc...Vamos a crear la carpeta LIB dentron de SRC y dentro el archivo prisma.ts
Volvi a encontrarme con una complicacion. en prisma.ts necesito importar PrismaClient de @prisma/client para poder  crear el nuevo cliente, y PrismaClient se subraya cmo error deiciendo que el modulo @prisma/client no lo exporta
Tuve muchas idas y vueltas, pero por lo que pude entender @prisma/client se encuentra en la carpeta node_module y no exporta a PrismaClient. la ruta correcta es esta dentro de la carpeta GENERATED que se crea al ejecutar prisma generate. Deje el archivo prisma.ts correctamente armado pero el problema de ahora es que new PrismaClient() requiere de un argumento que no se cual es. Estoy usando la version 7 de prisma y las anteriores no solicitaban este argumento, asiqeu para ma침ana debo investigar que argumento debo pasarle a PrismaClient

##Dia 7(24/11)Estuve haciendo cosas con chatGPT para lograr hacer que prisma funcione
En schema.prisma, en el objeto generator client cambie el valor del provider a "prisma-client-js" (antes no tenia el -js) y borre output que se침alaba el lugar para crear la carpeta GENERATED
Con eso al ejecutar npx prisma generate se creo en node_modules @prisma lo cual permite exportar PrismaClient
Tambien en schema.prisma en el objeto datasource db agregue url = env("DATABASE_URL"), que al parecer estaba faltando generando problema
Al realizar estos cambios ya debia poder levantarse prisma con trankilidad pero me tope con un detalle tecnico: Prisma tiene problemas cuando la carpetaq ue aloja al proyecto esta esta configurado para subirse a la nube. Como la carpeta del proyecto se aloja en C:/usuario/escritorio Windows lo tiene marcado como para subirlo siempre a la nube. Cuando trabaje con la inmobiliaria me maneje con docker o desde el pendrive. Opte por crear la carpeta PROYECTOS DEV, y dentro la carpeta VAULTCRYPT para copiar y pegar ahi la carpeta backend del proyecto.
Finalmente luego de unas idas y vueltas mas modifique package.json para levantar el proyecto haciendo npm run dev
Ahora prisma se levanta sin errores y parece que test.ts estaria funcionando correctamente. Pero hay que seguir con mas pruebas del funcionamiento

##Dia 8(25/11) Pruebas de los endopoints
Hoy quiero probar el correcto funciamiento de los endpoints y la base de datos. Para esto primero probe el endpoint test.ts y funciono bien. Incluso abri la aplcacion table plus para verificar que la base de datos se cargara
Ahora probare registrar usuarios. Primero la solicitud POST, hice los cambios correspondientes y mande por Postman el usuario numero 1:
{
    "name": "Oscar",
    "emailPrincipal": "oscar@vaultcrypt.com",
    "password": "claveSegura12345",
    "secretWord": "gonzalez"
}
Ha sido un exito, solo que olvide tambien hashear la palabra secreta, hare la modificacion y enviare al usuario numero 2:
{
    "name": "Mauricio",
    "emailPrincipal": "mauricio@vaultcrypt.com",
    "password": "contrase침a12345",
    "secretWord": "galacho"
}
Excelente, el post de nuevos usuarios funciona a la perfeccion.
Comence a trabajar en la solicitud GET, es una funcion para obtener a partir del token al usuario actual. El problema con el que me encontre es que al devolver el usaruario actual, la secretWord regresa con el segundo encriptado, haciendola inutil para el front-end. Mis dos opsiones son generar el token a partir del email y la secretWord o dejar la secretWord con la encriptacion del front-end
Lo he hablado con Copilot y llegamos al acuerdo de usar siguiente sistema: 
1_el frontend al momento del registro envia name, emailPrincipal, secretWord y password
2_el backend hashea secretWord y password (El hasheo es irreversible) y lo almacena juntocon las otras credenciasles en la base de datos
3_cuando el frontend solicite un login o un GET de usaurio le daremos la hashed secretWord derivada (version mas corta) para que haga el trabajo de encriptacion y desencriptacion correspondientes
4_ccuando el frontend tenga que encriptar o desencriptar no usara estrictamente la palabra secreta que proporciono el registro sin la hashed secretWord derivada que llamaremos cryptoWord. De esta manera la base de datos alamacenara la secretWord pero no sera util para encriptar o desencriptar
Este sistema es apto poruqe aun no trabajo en la solicitud GET del usuario ni en el login. Para el hashe se usara la libreria bcrypt y para el derivado se usara la libreria crypto
Estoy haciendo las pruebas con la solicitud GET y como el token habra expirado registre al tercer usuario: 
{
    "name": "Jack",
    "emailPrincipal": "jack@vaultcrypt.com",
    "password": "blackpearl",
    "secretWord": "ron"
}
Creo que deberia seguir probando porque la secretWord que queda luego de hashear y derivar es de 64 caracteres, pero lo dejare para ma침ana


##LO QUE SIGUE:
游댏 Autenticaci칩n y usuarios
- [x] POST /usuario: registro con hash y JWT
- [x] POST /login: validaci칩n de credenciales y emisi칩n de JWT
- [x] GET /usuario: devolver datos del usuario autenticado
- [x] PUT /usuario: permitir edici칩n de datos personales
游댎 Gesti칩n de cuentas cifradas
- [x] POST /cuenta: guardar cuenta cifrada (usando clave derivada del JWT o passphrase)
- [x] GET /cuenta: devolver cuentas del usuario autenticado

 3. Adaptaci칩n de objetos al frontend
[x]-Objetivo: Asegurar que los objetos usuario y cuenta que devuelve el backend coincidan con lo que espera el frontend.
[ ]-Acciones:
[x]-Revisar qu칠 campos necesita el frontend (ej. id, email, nombre, serviceName, etc.)
[x]-Eliminar campos innecesarios o sensibles (password, bcrypt, etc.)
[x]-Estandarizar nombres (userId vs idDue침o, servicePassword vs passwordEncriptada)
游댳 4. Migraci칩n a l칩gica de base de datos
[ ]-Objetivo: Reemplazar usuariosSimulados y cuentasSimuladas por persistencia real.
[ ]-Acciones:
[x]-Elegir tecnolog칤a (ej. Prisma + SQLite/PostgreSQL o Mongoose + MongoDB)
[x]-Crear modelos Usuario y Cuenta
[ ]-Reescribir los endpoints para usar findUnique, create, findMany, etc.
[ ]-Validar relaciones: cada cuenta debe tener un userId que exista
游댳 5. Despliegue en Vercel
[ ]-Objetivo: Publicar VaultCrypt para pruebas reales y feedback.
[ ]-Acciones:
[ ]-Subir el repo a GitHub
[ ]-Conectar Vercel al repo
[ ]-Configurar variables de entorno (JWT_SECRET, etc.)
[ ]-Probar endpoints desde Postman y desde el frontend en producci칩n

游 Bonus para la versi칩n 3
Cuando est칠s listo para escalar, pod칠s agregar:
- PUT y DELETE para cuentas
- Roles de usuario (admin, invitado, etc.)
- Compartir cuentas entre usuarios
- Historial de cambios o auditor칤a
- Educaci칩n visual sobre cifrado y seguridad


Aun falta:
-En la funcion handlerPost del archivo usaurio.ts adaptar la funcion para uqe reviba la palabra secreta y el nombre del usuario
-cuando hagamos la l칩gica de base de datos es necesario que obtengamos el objeto usuario de la misma para devolverlo junto con el token en login y register




http://localhost:3000/api/login POST de usuario nuevo enviando un email y una contrase침a
http://localhost:3000/api/usuario POST de usuario nuevo enviando un email y una contrase침a
http://localhost:3000/api/usuario PUT de usaurio enviando un objeto usuario
http://localhost:3000/api/usuario GET recibe el email del usuario logueado
http://localhost:3000/api/cuentas?idDue침o=N GET de cuentas donde N es el ID del usuario
http://localhost:3000/api/cuentas POST de cuentas enviando 
{
    "userId": N,
    "userName": "Nombre",
    "userEmail": "email",
    "serviceName": "servicio",
    "serviceUrl": "https://www.servicio.com.ar",
    "servicePassword": "contrase침a/clave",
    "serviceType": "Otros",
    "serviceDescription": "balblablabklalbablbalbalbalbalablba"
    }