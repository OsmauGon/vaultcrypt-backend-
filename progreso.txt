Hoy 14/11 vamos a empezar con el backend. Lo primero es crear la carpeta VAULTCRYPT-BACKEND y abrirla en el bash o windows power shell y ejecutar el comando npm init -y
Instalamos las dependencias de desarrollo y los typados: express, jsonwebtoken, bcrypt y dotenv
ejecutamos npx tsc --init para que se configure typescript y luego en tsconfig.json comentamos el compilerOptions que obtuvimos automaricamente por el siguiente:
"compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true
  }
Creamos la carpeta SRC y dentro las carpetas API y UTILS
A la par de SRC creamos los archivos .env y vercel.json
El archivos vercel.json es para configurar l servicio de Vercel que es la plataforma donde vamos a desplegar el backend y lo que escribimos dentro es:
{
  "functions": {
    "api/**/*.ts": {
      "runtime": "nodejs20.x"
    }
  }
}
Establecimos la primera variable de entonrno JWT_SECRET
Empezamos a trabajar con el primer endpoint. Creamos el archivo usuario.ts dentro de la carpeta API y declaramos la funcion asincrona handlerPost que recibira el cuerpo de la solicitud y lo desestructurara  en email y password para procesarlo y devolver el objeto usuario, el token y el mensaje de exito. Esto es para hacer el registro de un usuario, pero falta adaptarlo para uqe reviba la palabra secreta y el nombre del usuario
Vamos a crear dentro de SRC la carpeta TYPES y dentro del archivo vercel.ts. Aqui vamos a declarar y exportar las interfaces VercelRequest y VercerResponse
Procederemos a haer una testeo local con Postman haciendo una solicitud POST al endpoint http://localhost:3000/api/usuario con el cuerpo {"email": "oscar@vaultcrypt.com","password": "claveSegura123"}
Salto el primer error. Primero que nada nos falto desarrollar en index.ts la configuracion de las variables de entorno y la aplicacion de express. Una vez hecho eso y ejecutando npx ts-node src/index.ts en la consola del VScode el servidor se levanto y pudimos realizar la solicitud POST de postman satisfactoriamente
Lo que sigue es la primer subida a github para eso ejecutamos git init en la consola del VScode y creamos el archivo .gitignore que debe enlistar a node_module, .env y a dist/

## Dia 2 (17/11)

Hoy vamos a trabajar en el endpoint del login, ya tenemos el endpoint de resgistro en usuario.ts. Empezaremos creadon el archivo login.ts dentro de la carpeta API.
Declaramos la funcion handlerPostLogin para verificar el logueo de un usuario y lo dejamos operativo y probado por Postman
Al empezar a trabajar con el endpoint GET de usuarios la IA sugirio extender la funcion del archicos usuario.ts, por lo que le hare las siguientes modificaciones: cambiare el nombre a usersHandler y metera la logica del registro de usuario dentro de un IF que verifique el metodo de la solicitud y use ELSE IF para las otras dos (GET y PUT) de esta manera unificara las funciones POST, GET y PUT en el archivo usuario.ts
Hemos dejado creados las 3 funciones recien mencionada dejando mensajes del lugar donde va la logica de base de datos

## Dia 3 (18/11)
Hoy vamos a trabajar los endpoints de relacionados a la gestion de cuentas, principalmente desarrollaremos el GET y el POST
Primero vamos a ir a la carpeta TYPES para crear el tipado de cuentas
Le pedi a copilot para hacer el desarrollo del endpoint, pero no me convencio la respuesta. Asique tome la use el POST de usuario.ts y lo adapte para funcionar con cuentas. Me tope con el problmea de que necesito obtener el id del usuario desde el frontend para ponerlo como userId de la nueva cuenta
Lo que se me ocurrio es que el id del usuario este cifrado dentro del token junto con el email del usuario. Esto plantea que debo modificar la funcion de login y register
Para evitar complicaciones decidi que al hacer login o register el backend devuelva el token y el objeto usuario. Con esto solo pude dejar completo el POST de nuevaCuenta. falta probarlo

## Dia 4 (19/11)
Empezaremos el dia probando el endpoint de cuentas. La prueba con Postman ha funcionado perfectamente
Seguiremoos con el GET de las cuentas. Como hicimos con POST tomaremos el codigo de GET de usuario.ts y lo adaptaremos
He dicidio crear un middleware para verificar el token y usarlo en las solicitudes de post y GET  de la gestion de cuentas. Tambien lo usare cuando haya que modificar los datos del usaurio. Creare el archivo tokenverificator.ts dentro de la carpeta UTILS 
He dajado operativos y probados el POST y GET de gestion de cuentas a traves de la verificacion por token

##Falta hacer: editar el PUT de usuario.ts para que verifique por token
Dia 5 (20/11)
Para hoy quiero dejarr todo listo para trabajar en la implementacion de la logica de base de datos. Para esto debo dejar los objeto usuario y cuenta acordes al front-end.
Empezaremos con el objeto Usuario le agregue name, emailPrincipal, emailList, role y secretWord
El objeto accounts desde un principio lo construi del modo en lo que lo quiero
Ya actualice el PUT para usar la funcion del archivo tokenverificator.ts y antes de terminar el dia actualizare el objeto Account o Cuenta del front-end

## Dia 6(21/11) Crearemos y aplicaremos la logica de base de datos
Las opsiones son PostgreSQL y MongoDB. Segun entiendo PostgreSQL es mas estricto con el tipado asique lo usaremos ya que va a la par con typescript y el OMR sera Prisma
Primero definiremos los modelos de Usuario y Cuenta. Voy a crear la carpeta MODELS y dentro el archivo prismaModels.ts (probaablemente no lo use en el flujo del proyecto) que es donde voy a declarar los modelos. Ya que ambos tienen un campo de opsiones (Usuario tiene role y Cuenta tiene serviceType) a cada uno le haremos un enum para que prisma les asigne unicamente esos valores. Lo que sigue es ejecutar en la terminal un npm install prisma @prisma/client para instalar las dependencias de Prisma y luego lo ejecutare con npx prisma init
Una vez iniciado prisma la url de base de datos que se creo en el archivo .env y lo dejaremos asi: DATABASE_URL="postgresql://mauricio:gonzalez@localhost:5432/vaultcrypt"
Podemos ver que se creo la carpeta PRISMA y dentro el archivo shema.prisma y luego para quedarnos tranquilos ejecutamos el comando npx prisma validate que es propio de prisma y verifica que las relaciones y asignaciones esten correctas
Lo que sigue es ejecutar npx prisma migrate dev --name init, esto crea las tablas en la base de datos segun el modelo y salto un problema: Can't reach database server at `localhost:5432`. Esto es porque la base de datos no esta levantada ni corriendo asique haremos lo siguiente: 
ir a https://www.postgresql.org/download/ y descargar PostgreSQL para Windows. Instalamos PostgreSQL en la compu y declaramos como contrase√±a "gonzalez" y el puerto "5432"
Una vez completada la instalacion modificamos la url del archivo .env y la dejamos como DATABASE_URL="postgresql://postgres:gonzalez@localhost:5432/vaultcrypt". Volvimos a ejecutar npx validate y como salio bien ahora pasamos a la migracion con npx prisma migrate dev --name init. Fue un exito asique ya estamos listos para generar el cliente de prisma
El cliente de prisma es como la libreria que nos dara los metodos findMany, findUnique , etc...Vamos a crear la carpeta LIB dentron de SRC y dentro el archivo prisma.ts
Volvi a encontrarme con una complicacion. en prisma.ts necesito importar PrismaClient de @prisma/client para poder  crear el nuevo cliente, y PrismaClient se subraya cmo error deiciendo que el modulo @prisma/client no lo exporta
Tuve muchas idas y vueltas, pero por lo que pude entender @prisma/client se encuentra en la carpeta node_module y no exporta a PrismaClient. la ruta correcta es esta dentro de la carpeta GENERATED que se crea al ejecutar prisma generate. Deje el archivo prisma.ts correctamente armado pero el problema de ahora es que new PrismaClient() requiere de un argumento que no se cual es. Estoy usando la version 7 de prisma y las anteriores no solicitaban este argumento, asiqeu para ma√±ana debo investigar que argumento debo pasarle a PrismaClient

##Dia 7(24/11)Estuve haciendo cosas con chatGPT para lograr hacer que prisma funcione
En schema.prisma, en el objeto generator client cambie el valor del provider a "prisma-client-js" (antes no tenia el -js) y borre output que se√±alaba el lugar para crear la carpeta GENERATED
Con eso al ejecutar npx prisma generate se creo en node_modules @prisma lo cual permite exportar PrismaClient
Tambien en schema.prisma en el objeto datasource db agregue url = env("DATABASE_URL"), que al parecer estaba faltando generando problema
Al realizar estos cambios ya debia poder levantarse prisma con trankilidad pero me tope con un detalle tecnico: Prisma tiene problemas cuando la carpetaq ue aloja al proyecto esta esta configurado para subirse a la nube. Como la carpeta del proyecto se aloja en C:/usuario/escritorio Windows lo tiene marcado como para subirlo siempre a la nube. Cuando trabaje con la inmobiliaria me maneje con docker o desde el pendrive. Opte por crear la carpeta PROYECTOS DEV, y dentro la carpeta VAULTCRYPT para copiar y pegar ahi la carpeta backend del proyecto.
Finalmente luego de unas idas y vueltas mas modifique package.json para levantar el proyecto haciendo npm run dev
Ahora prisma se levanta sin errores y parece que test.ts estaria funcionando correctamente. Pero hay que seguir con mas pruebas del funcionamiento

##Dia 8(25/11) Pruebas de los endopoints
Hoy quiero probar el correcto funciamiento de los endpoints y la base de datos. Para esto primero probe el endpoint test.ts y funciono bien. Incluso abri la aplcacion table plus para verificar que la base de datos se cargara
Ahora probare registrar usuarios. Primero la solicitud POST, hice los cambios correspondientes y mande por Postman el usuario numero 1:
{
    "name": "Oscar",
    "emailPrincipal": "oscar@vaultcrypt.com",
    "password": "claveSegura12345",
    "secretWord": "gonzalez"
}
Ha sido un exito, solo que olvide tambien hashear la palabra secreta, hare la modificacion y enviare al usuario numero 2:
{
    "name": "Mauricio",
    "emailPrincipal": "mauricio@vaultcrypt.com",
    "password": "contrase√±a12345",
    "secretWord": "galacho"
}
Excelente, el post de nuevos usuarios funciona a la perfeccion.
Comence a trabajar en la solicitud GET, es una funcion para obtener a partir del token al usuario actual. El problema con el que me encontre es que al devolver el usaruario actual, la secretWord regresa con el segundo encriptado, haciendola inutil para el front-end. Mis dos opsiones son generar el token a partir del email y la secretWord o dejar la secretWord con la encriptacion del front-end
Lo he hablado con Copilot y llegamos al acuerdo de usar siguiente sistema: 
1_el frontend al momento del registro envia name, emailPrincipal, secretWord y password
2_el backend hashea secretWord y password (El hasheo es irreversible) y lo almacena juntocon las otras credenciasles en la base de datos
3_cuando el frontend solicite un login o un GET de usaurio le daremos la hashed secretWord derivada (version mas corta) para que haga el trabajo de encriptacion y desencriptacion correspondientes
4_ccuando el frontend tenga que encriptar o desencriptar no usara estrictamente la palabra secreta que proporciono el registro sin la hashed secretWord derivada que llamaremos cryptoWord. De esta manera la base de datos alamacenara la secretWord pero no sera util para encriptar o desencriptar
Este sistema es apto poruqe aun no trabajo en la solicitud GET del usuario ni en el login. Para el hashe se usara la libreria bcrypt y para el derivado se usara la libreria crypto
Estoy haciendo las pruebas con la solicitud GET y como el token habra expirado registre al tercer usuario: 
{
    "name": "Jack",
    "emailPrincipal": "jack@vaultcrypt.com",
    "password": "blackpearl",
    "secretWord": "ron"
}
Creo que deberia seguir probando porque la secretWord que queda luego de hashear y derivar es de 64 caracteres, pero lo dejare para ma√±ana

##Dia 9(26/11) Hoy quero terminar con todos los endpoints de una vez
Para resumir no dar vueltas vamos manejar la palabra secreta de la siguente manera: 
const user = { id, secretWord: "miClaveSuperSecreta" };

    // Derivar hash SHA-256
    const fullHashBuffer = crypto.createHash("sha256")
      .update(user.secretWord)
      .digest();

    // Convertir a Base64 y truncar a 12 caracteres
    const shortKey = fullHashBuffer.toString("base64").slice(0, 12);
Esto haya que cuando se haga la solicitud GET el servidor tome la palabra secreta hasheada en la base de datos, la derive con crypto y devuelva solo los primeros 12 caracteres. De esta manera la palabra secreta queda completamente desconocida para el backend y el front-end, mientras que el usuario ve una encriptacion con una secretWord automatica generada al momento de registrarse. Para ahorrar codigo creare el archivo swmannager.ts en la carpeta UTILS y declarare la funcion que toma el hashed secretWord y la devuelve como la recivira el usuario
Pasemos al PUT de usuarios, sera parecido al register, primero verificara por token al usuario, luego tomara name, emailPrincipal, emailList y password para actualizar el registro del usuario en la base de datos segun  se obtenga de un findUnique. Ya reemplazamos la logica de modificar usuariosSimulados asiqeu probaremos con Postman creando un nuevo usuario:
{
    "name": "William",
    "emailPrincipal": "turner@vaultcrypt.com",
    "password": "flayingdutchman",
    "secretWord": "will"
} 
el GET funciono bien y vamos a probar el PUT con:
{
    "name": "Will Turner",
    "emailPrincipal": "will@vaultcrypt.com",
    "password": "flayingdutchman",
    "emailList" : ["bootstrap@gmail.com","bill@gmail.com"],
}
La prueba resulto excelente.
Ahora vamos a seguir con el POST de login. hicimos los cambios correspondientes y probamos los 4 usuarios creado cons Postman. Todo resulto perfecto
Para seguir haremos pruebas de primero un login del primer usuario: {"email":"oscar@vaultcrypt.com","password": "claveSegura12345"}. Luego haremos un PUT para modificarle todo los campos: {"name": "OscarMau","emailPrincipal": "oscar@vaultcrypt.com","emailList": ["email1@gmail.com","email2@gmail.com"],"password": "contrase√±a1"}. Luego volvemos a hacer una solicitud login del usuario 2 para obtener el token del mismo: {"emailPrincipal": "mauricio@vaultcrypt.com","password": "contrase√±a12345"} y luego hacer un GET para obtener todos los datos de ese usuario. Como todas las pruebas salieron correctas seguimos con los endpoints de cuenta.ts
Empezando a trabajar con el POST de una cuenta nueva encontre mi primer conflicto: los datos mas sensibles del objeto Cuenta son userEmail, servicePassword y serviceDescription y al haber entendido que el hasheo es irreversible entonces deseo mantener mi postura de una doble encriptaci√≥n va a ser necesario encriptarlos de una manera reversible. Para esto voy a crear el archivo encryptMannage.ts dentro de la carpeta UTILS y va a contener las funciones que encrypten y desencripten los datos sensibles de un objeto Cuenta usando la libreria crypto-js. Ya he completado las modificaciones de la funcion accountHandler en POST  y GET. Pasemos a probar con postman. Primero hare 10 POST de cuentas, pero la primero cuenta va a ser:
{
    "userId":"1",
    "userName":"Oscar",
    "userEmail": " prueba@gmail.com",
    "serviceName": "Prueba",
    "serviceUrl": "https://www.prueba.com",
    "servicePassword": "Pass1234!",
    "serviceType":"Otros",
    "serviceDescription": " Cuenta personal de prueba",
}
Ambas pruebas fueron exitosas


##Dia 10(27/11) Hoy debo subir el backend a vercel
Empece el dia revizando los puntos faltantes. El primero quedo obsoleto asiqeuue lo borre. El segundo que dice: "cuando se aplique la logica db, asegurarse de devolver el objeto usuario en login y register". Habiamos acordado que el login y GET de usuario no devuelven el objeto usuario completo asque quedo pendiente modificar el register para que envie las partes necesarias del objeto usuario (id, name, emailList, role y secretWord hasehada y derivada). Ahora el POST de usuario.ts al salir existoso devuelve un mensaje de exito, el token y el objeto user. Porbamos con postman usando el sigueinte usuario:
{
    "name": "Hector",
    "emailPrincipal": "hbarbossa@vaultcrypt.com",
    "password": "queenannarevenge",
    "secretWord": "treasure"
    }
La prueba fue exitosa
En la carpeta UTILS decidi crear el archivo authMiddleware.ts que exporta una funcion que verifica si el id del usuario obtenido del email obtenido del token, corresponde al idDue√±o enviado en la url del GET. Esto espara sanar mi preocupacion de uqe cualquier usuario con un token valido reciba las cuentas de cualquier otro usuario al logueado
Por conflictos de tipado reemplace los VercelRequest y VercerResponse por Request y Response de express.
En pos de hacer los prepararivos en vercel haremos algunas modificaciones:
-en index.ts debemos comentar el app.listen ya que generara problemas al momento del deploy
-en vercel.json teniamos el objeto {"functions": {"api/**/*.ts": {"runtime": "nodejs20.x"}}}. Este vercel.json que me pasaste est√° configurando el runtime de las funciones en api/**/*.ts a Node.js 20, lo cual es correcto si tu backend estuviera dividido en m√∫ltiples archivos dentro de /api.
Pero como vos tenemos un servidor Express centralizado en index.ts, lo ideal es ajustar el vercel.json para que todas las rutas apunten a ese archivo. De lo contrario, Vercel va a esperar funciones sueltas en /api y no va a invocar tu index.ts. asique el codigo uqe va en vercel.json es:
{
  "version": 2,
  "builds": [
    { "src": "index.ts", "use": "@vercel/node" }
  ],
  "routes": [
    { "src": "/(.*)", "dest": "index.ts" }
  ],
  "functions": {
    "index.ts": {
      "runtime": "nodejs20.x"
    }
  }
}
Ya tenemos la estructura del proyecto y el vercel.json listo. El siguiente paso hacia el despliegue es preparar el entorno de Vercel y subir tu c√≥digo:

Paso 2: Configurar entorno en Vercel
- Subir el repo a GitHub
- Asegurate de que tu index.ts, vercel.json, package.json y tsconfig.json est√©n en la ra√≠z del proyecto.
- Inclu√≠ tu .gitignore para no subir node_modules ni .env.
- Importar el proyecto en Vercel
- Entr√° a vercel.com.
- Clic en New Project ‚Üí seleccion√° tu repo.
- Framework: eleg√≠ Other (porque us√°s Express).
- Configurar variables de entorno
- En Project Settings ‚Üí Environment Variables, agreg√°:
- JWT_SECRET ‚Üí tu clave secreta.
- DATABASE_URL ‚Üí la cadena de conexi√≥n de Prisma.
- ENCRYPT_SECRET (si tu cifrado lo requiere).
- Defin√≠ valores tanto para Production como para Preview.
- Build & Output
- Vercel va a ejecutar vercel-build (que definiste como tsc) para compilar tu TypeScript.
- El resultado ser√° tu index.js en dist/ (o directamente compilado por Vercel).
- Gracias al vercel.json, todas las rutas se redirigen a tu index.ts.
-En vercel.json debemos asegurarnos que si algo usa index.ts, este puesto como src/index.ts para que vercel busque el archivo index.ts dentro de la carpeta SRC


Ya en la pagina de Vercel importamos el repositorio de GitHub, donde nos pregunta el framework ponemos "Other". En las variables de entorno declaramos JWT_SECRET que usaremos el primer nombre de mi padre + secret (***secret) y en DATABASE_URL pondre postgresql://mauricio:gonzalez@host:5432/vaultcrypt?schema="public" pero se estan presentado dificultades. 
He decidido dejar por hoy y posponer el deploy, aun no estamos listos para el deploy en vercel asique definire los siguientes objetivos y retomare ma√±ana:
- Etapa 1 (ma√±ana): configurar CORS y definir la base de datos persistente (Neon o Supabase).
- Etapa 2 (cierre de esta semana): hacer el deploy en Vercel y validar todas las funciones con Postman.
- Etapa 3 (pr√≥xima semana): conectar tu frontend en Netlify con el backend en Vercel y dejar el proyecto funcionando de punta a punta.

##Dia 11(28/11) segumos con el proceso de deploting
Primero instalare las cors y las configurare en index.ts. en origin dejare el localhost 3000 para pruebas locales, dos endpooints genericos de servicios de despliegue y la url del front-end desplegado en Netlify
Lo que sigue es la definicion de la base de datos. Esto es paara que la base de datos se aloje en un lugar y este disponible para se accedida por el backend. Ingresare a neon.com para registrarme con mi GitHub. Ya cree el proyecto y ahora debo instalar el CLI de neom con npm install -g neonctl para disponer de comando de configuracion de neon. Lo que sigue es ejecutar npx neon init
El despliegue se hizo correctamente, pero hay errores hacen que se crashee la pagina que estoy tratando de localizar. El primero es que en "script" del package.json no esta la linea "postinstall": "prisma generate" - Esto asegura que Vercel genere el Prisma Client al instalar dependencias, evitando el crash t√≠pico de Cannot find module '.prisma/client'..
Otro error importante que genera crasheo es que en index.ts: falta que agregamos export default (req: VercelRequest, res: VercelResponse) => {app(req, res);}; para que Vercel pueda invocar tu Express app como funci√≥n serverless.
Seguimos con problemas, esta vez no con el deploying, pero si con construccion de la app. Vercel se queja de que no pudo instalar tus dependencias. Esto suele deberse a problemas en el package.json o en las dependencias mismas.
Al pasarle casi todo el codigo de package.json a copilot me ha dado las siguiente instrucciones: 

-el paquete crypto de npm es obsoleto y suele romper builds.
üëâ Soluci√≥n: elimin√° "crypto": "^1.0.1" de dependencies
-est√°s usando . La versi√≥n 5 todav√≠a est√° en beta y puede dar problemas en entornos serverless.
üëâ Soluci√≥n: baj√° a la versi√≥n estable 4.x haciendo npm install express@4
-vercel usa Node 18 por defecto. Si quer√©s Node 20 (como pusiste en tu vercel.json)
üëâ Soluci√≥n: ten√©s que declararlo en package.json: agregar en package.json "engines":{"node":"20.x"}
- en Vercel, los devDependencies tambi√©n se instalan, pero es m√°s seguro mover Prisma a dependencies porque se usa en runtime para generar el cliente.
üëâ Soluci√≥n: mover "prisma" a dependencies

UNA VEZ hecho eso debo borrar node_modules y package-lock.json y volver a ejecutar npm install
Tuve mas problemas con prisma y su condenada version 7 asiqe optamos por bajar a otra vercion con el comando npm install prisma@5.14.0 @prisma/client@5.14.0 y ahora debo volver a ejecutar npx prisma generate
Finalmente el deploy funciono bien y la pagina del dominio no tiene errores (creo). Lo qie sigue es probar con Postman ingresando un nuevo usuario
Falle al crear un nuevo usuario, pero el error viene de la mano de la base de datos y su alojamiento (neon). Copilot decie que el url de las variables de entorno puestas en vercel deben incluir ?sslmode=require asique la modifique y quedo asi "postgresql://postgres:gonzalez@localhost:5432/vaultcrypt?sslmode=require"
Si bien el backend esta subido y funcionando, ninguna de mis pruebas de registrar un usuario han funcionado. Pero tengo la pista de que el problema es que prisma no puede alcazar la base de datos segun el puerto (o algo asi). Ma√±ana segiremos tratando


Dia 12(1/12) Seguimos trabajando en el deploying
Empece el dia planteando mis pasos segun la pista que obtuve el ultimo dia: el problema viene de que no podemos alcanzar la base de daton en Neon. Encontre que el proyecto esta subido correctamente y dividido en dos ramas: deployment y production. Cada uno tiene su propia connection string o url para conectarse y sus funcionalidades respectivamente son pruebas/desarrollo y servico activo. Con esto es facil deducir que el despliegue en vercel esta tratando de conectarce a una base de datos inexistent.
Como han pasado unos dias Neon ha desabilitado o pausado ambas ramas para ahorrar recursos. asique las reeactive (no estoy seguro de como) y luego de hacerlo hice lo siguiente:
- ejecute npx prisma migrate deploy: entonces se crearon las tablas
- ejecute db pull : para probar la coneccion local con le base en Neon y salio bien. 
- ejectute prisma generate : para que mi cliente se adapte a la url especificada el schema.
- en LIB/prisma.ts arme una funcion que solicita los registros de una tabla ni bien se levnate el backend 
- Levante el backend usando npm run dev y se me mostro en consola el array vacio que significa qeu la tabla existe y funciona
Dejare en .ENV las url para poder alternar entre la rama production y development y repeti el proceso para actualizar la base de datos de esta rama. Ya quedo bien porque levante el backend usando npm run dev y y se me mostro en consola el array vacio que significa qeu la tabla existe y funciona

PARA FUTUROS DESPLIEGUES:
el flujo completo es:
- verificacion de estructura del proyecto (archivos raices, carpetas y tipados)
- Configurar base de datos persistente y probar migraciones.
- Configurar CORS en tu backend.
- Subir variables de entorno a Vercel.
- Reci√©n ah√≠ hacer el deploy.

















































##LO QUE SIGUE:
üîê Autenticaci√≥n y usuarios
- [x] POST /usuario: registro con hash y JWT
- [x] POST /login: validaci√≥n de credenciales y emisi√≥n de JWT
- [x] GET /usuario: devolver datos del usuario autenticado
- [x] PUT /usuario: permitir edici√≥n de datos personales
üîè Gesti√≥n de cuentas cifradas
- [x] POST /cuenta: guardar cuenta cifrada (usando clave derivada del JWT o passphrase)
- [x] GET /cuenta: devolver cuentas del usuario autenticado

 3. Adaptaci√≥n de objetos al frontend
[x]-Objetivo: Asegurar que los objetos usuario y cuenta que devuelve el backend coincidan con lo que espera el frontend.
[ ]-Acciones:
[x]-Revisar qu√© campos necesita el frontend (ej. id, email, nombre, serviceName, etc.)
[x]-Eliminar campos innecesarios o sensibles (password, bcrypt, etc.)
[x]-Estandarizar nombres (userId vs idDue√±o, servicePassword vs passwordEncriptada)
üîπ 4. Migraci√≥n a l√≥gica de base de datos
[ ]-Objetivo: Reemplazar usuariosSimulados y cuentasSimuladas por persistencia real.
[ ]-Acciones:
[x]-Elegir tecnolog√≠a (ej. Prisma + SQLite/PostgreSQL o Mongoose + MongoDB)
[x]-Crear modelos Usuario y Cuenta
[x]-Reescribir los endpoints para usar findUnique, create, findMany, etc.
[x]-Validar relaciones: cada cuenta debe tener un userId que exista
üîπ 5. Despliegue en Vercel
[ ]-Objetivo: Publicar VaultCrypt para pruebas reales y feedback.
[ ]-Acciones:
[ ]-Subir el repo a GitHub
[ ]-Conectar Vercel al repo
[ ]-Configurar variables de entorno (JWT_SECRET, etc.)
[ ]-Probar endpoints desde Postman y desde el frontend en producci√≥n

üß† Bonus para la versi√≥n 3
Cuando est√©s listo para escalar, pod√©s agregar:
- PUT y DELETE para cuentas
- Roles de usuario (admin, invitado, etc.)
- Compartir cuentas entre usuarios
- Historial de cambios o auditor√≠a
- Educaci√≥n visual sobre cifrado y seguridad


Aun falta:

-recordar el tema de la palabra secreta: no es modificable y no es exactamente la que el usuario brinda al registrarse


DEVILIDADES O COSAS QUE NO SON COMO PENSE:

-la secretWord del usuario no es la que brinda al registrarse y nunca puede ser cambiada
-la verificacion por token que usan algunas solicitudes deberia ser un middleware para ahorrar codigo
-con el token correcto cualquier usuario podria obtener los registros del usuario que mande en el endpoin, el GET de cuenta.ts deberia comparar el id el usuario logueado con el del enviado en el endpoint


http://localhost:3000/api/login POST de usuario nuevo enviando un email y una contrase√±a
http://localhost:3000/api/usuario POST de usuario nuevo enviando un email y una contrase√±a
http://localhost:3000/api/usuario PUT de usaurio enviando un objeto usuario
http://localhost:3000/api/usuario GET recibe el email del usuario logueado
http://localhost:3000/api/cuentas?idDue√±o=N GET de cuentas donde N es el ID del usuario
http://localhost:3000/api/cuentas POST de cuentas enviando 
{
    "userId": N,
    "userName": "Nombre",
    "userEmail": "email",
    "serviceName": "servicio",
    "serviceUrl": "https://www.servicio.com.ar",
    "servicePassword": "contrase√±a/clave",
    "serviceType": "Otros",
    "serviceDescription": "balblablabklalbablbalbalbalbalablba"
    }